
struct VertexDataInput {
	float4 vertex: POSITION;
	float3 normal: NORMAL;
	float3 color: COLOR;
};

struct VertexDataOutput {
	float4 projv  : POSITION;
	float4 color : COLOR;
	float3 vertex: TEXCOORD0;
	float3 normal: TEXCOORD1;
};

struct PixelDataOutput {
	float4 color : COLOR0;
};

VertexDataOutput VertexMain(VertexDataInput vdi, 
  uniform float4x4 modelViewProj) {

  VertexDataOutput ret;
  ret.projv = mul(modelViewProj, vdi.vertex);
  ret.color = float4(vdi.color, 1.0f);
  ret.vertex = vdi.vertex.xyz;
  ret.normal = vdi.normal;

  return ret;

}

TRIANGLE void GeometryMain(AttribArray<VertexDataOutput> tverts,
	uniform float4x4 modelViewProj) {

	emitVertex(tverts[0]);
	emitVertex(tverts[1]);
	emitVertex(tverts[2]);
	return;

}

bool intersectsQuad(float3 interPoint, float t, 
               float3 quad0, float3 quad1, float3 quad2, float3 quad3, float3 quadNorm)
{
        float3 inter0 = cross(quad1-quad0, interPoint - quad0);
        float3 inter1 = cross(quad2-quad1, interPoint - quad1);
        float3 inter2 = cross(quad3-quad2, interPoint - quad2);
        float3 inter3 = cross(quad0-quad3, interPoint - quad3);

        float interNorm0 = dot(quadNorm, inter0);
        float interNorm1 = dot(quadNorm, inter1);
        float interNorm2 = dot(quadNorm, inter2);
        float interNorm3 = dot(quadNorm, inter3);

        if((interNorm0 > 0 && interNorm1 > 0 &&
           interNorm2 > 0 && interNorm3 > 0) || 
           (interNorm0 < 0 && interNorm1 < 0 &&
           interNorm2 < 0 && interNorm3 < 0) && t > 0)
        {
            return true;
        }
        else
        {
            return false;
        }
}

PixelDataOutput FragmentMain(
    VertexDataOutput pdi, 
	uniform float3 eyeCam, 
    uniform samplerCube cMap,
    uniform float bgRendering, 
    uniform float floorRendering,
    uniform sampler2D floor, 
    uniform sampler2D depth,
    uniform float3 quad0,
    uniform float3 quad1, 
    uniform float3 quad2, 
    uniform float3 quad3) 
    {

    
    PixelDataOutput returnColor;

    float3 curPix = pdi.vertex;
    float3 eyeToPix = normalize(curPix - eyeCam);

    
    
    if(bgRendering == 0.0f)
    {
        float3 pixNorm = normalize(pdi.normal);
        
        float3 reflecVec = normalize(eyeToPix - 2 * dot(eyeToPix, pixNorm) * pixNorm);
    
        float3 quadNorm = normalize(cross(quad0 - quad1, quad2 - quad1));

        float t = dot(quadNorm, quad1 - curPix) / dot(quadNorm, reflecVec);

        float3 interPoint = curPix + reflecVec * t;        

        if(intersectsQuad(interPoint, t, quad0, quad1, quad2, quad3, quadNorm))
        {
            float2 quadTexCoords = float2((interPoint.x - quad1.x)/(quad2.x-quad1.x), (interPoint.z - quad3.z)/(quad2.z-quad3.z)) * 10.0f;
            returnColor.color = tex2D(floor, quadTexCoords);  
        }  
        else
        { 
          returnColor.color = texCUBE(cMap, reflecVec);
        }
    }
    else
    {
        returnColor.color = texCUBE(cMap, eyeToPix);
    }

    return returnColor;
}




