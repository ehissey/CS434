
struct VertexDataInput {
	float4 vertex: POSITION;
	float3 normal: NORMAL;
	float3 color: COLOR;
};

struct VertexDataOutput {
	float4 projv  : POSITION;
	float4 color : COLOR;
	float3 vertex: TEXCOORD0;
	float3 normal: TEXCOORD1;
};

struct PixelDataOutput {
	float4 color : COLOR0;
};

VertexDataOutput VertexMain(VertexDataInput vdi, 
  uniform float4x4 modelViewProj) {

  VertexDataOutput ret;
  ret.projv = mul(modelViewProj, vdi.vertex);
  ret.color = float4(vdi.color, 1.0f);
  ret.vertex = vdi.vertex.xyz;
  ret.normal = vdi.normal;

  return ret;

}

TRIANGLE void GeometryMain(AttribArray<VertexDataOutput> tverts,
	uniform float4x4 modelViewProj) {

	emitVertex(tverts[0]);
	emitVertex(tverts[1]);
	emitVertex(tverts[2]);
	return;

}

bool intersectsQuad(float3 interPoint, float t, 
               float3 quad0, float3 quad1, float3 quad2, float3 quad3, float3 quadNorm)
{
        float3 inter0 = cross(quad1-quad0, interPoint - quad0);
        float3 inter1 = cross(quad2-quad1, interPoint - quad1);
        float3 inter2 = cross(quad3-quad2, interPoint - quad2);
        float3 inter3 = cross(quad0-quad3, interPoint - quad3);

        float interNorm0 = dot(quadNorm, inter0);
        float interNorm1 = dot(quadNorm, inter1);
        float interNorm2 = dot(quadNorm, inter2);
        float interNorm3 = dot(quadNorm, inter3);

        if((interNorm0 > 0 && interNorm1 > 0 
            && interNorm2 > 0 && interNorm3 > 0) 
            ||(interNorm0 < 0 && interNorm1 < 0 
               && interNorm2 < 0 && interNorm3 < 0) 
            && t > 0)
        {
            return true;
        }
        else
        {
            return false;
        }
}

bool intersectsFrust(float3 [8] fPoints, float3 reflecVec, float3 curReflecPoint, 
            out float3 nPoint, out float3 fPoint, int out colCheck)
{
    float3 quadNorm;

    bool hasT1 = false;
    bool hasT2 = false;


    float t1, t2;

    float3 intPoint1, intPoint2;

    float3[6][4]fQuadPoints= {{fPoints[0], fPoints[1], fPoints[2], fPoints[3]},
                              {fPoints[4], fPoints[5], fPoints[6], fPoints[7]},
                              {fPoints[3], fPoints[2], fPoints[6], fPoints[7]},
                              {fPoints[4], fPoints[5], fPoints[1], fPoints[0]},
                              {fPoints[4], fPoints[0], fPoints[3], fPoints[7]},
                              {fPoints[1], fPoints[2], fPoints[6], fPoints[5]}};

    
               
    for(int i = 0; i < 6; i++)
    {
        quadNorm = normalize(cross(fQuadPoints[i][0] - fQuadPoints[i][1], 
                                   fQuadPoints[i][2] - fQuadPoints[i][1]));
        
        float t = dot(quadNorm, fQuadPoints[i][1] - curReflecPoint) / dot(quadNorm, reflecVec);

        float3 interPoint = curReflecPoint + reflecVec * t;  

        if(intersectsQuad(interPoint, t, 
           fQuadPoints[i][0], fQuadPoints[i][1], 
           fQuadPoints[i][2], fQuadPoints[i][3], 
           quadNorm))
        {
            if(!hasT1)
            {
                t1 = t;
                hasT1 = true;
                intPoint1 = interPoint;
                colCheck = i;
            }
            else
            {
                t2 = t;
                hasT2 = true;
                intPoint2 = interPoint;

                colCheck = i;
            }
        }
    }

    if(hasT2)
    {
        if(t1 < t2)
        {
            nPoint = intPoint1;
            fPoint = intPoint2;
        }
        else
        {
            nPoint = intPoint2;
            fPoint = intPoint1;
        }
    }
    else if(hasT1)
    {
        nPoint = curReflecPoint;
        fPoint = intPoint1;
    }

    return hasT1;
}



PixelDataOutput FragmentMain(
    VertexDataOutput pdi, 
	uniform float3 eyeCam, 
    uniform samplerCube cMap,
    uniform float bgRendering, 
    uniform float floorRendering,
    uniform sampler2D floor, 
    uniform sampler2D depth,
    uniform float3 quad0,
    uniform float3 quad1, 
    uniform float3 quad2, 
    uniform float3 quad3,
    uniform float3 fPoints[8]) 
    {

    
    PixelDataOutput returnColor;

    float3 curReflecPoint = pdi.vertex;
    float3 eyeToPix = normalize(curReflecPoint - eyeCam);

    float3 nPoint, fPoint;
    
    
    if(bgRendering == 0.0f)
    {
        float3 pixNorm = normalize(pdi.normal);
        
        float3 reflecVec = normalize(eyeToPix - 2 * dot(eyeToPix, pixNorm) * pixNorm);
    
        float3 quadNorm = normalize(cross(quad0 - quad1, quad2 - quad1));

        float t = dot(quadNorm, quad1 - curReflecPoint) / dot(quadNorm, reflecVec);

        float3 interPoint = curReflecPoint + reflecVec * t;

        //Remove after color checking
        int colCheck;

        if(intersectsFrust(fPoints, reflecVec, curReflecPoint, nPoint, fPoint, colCheck))
        {
            //START PROJECTION ON DEPTH IMAGE AND FIND VALUE
            /*
                  {{fPoints[0], fPoints[1], fPoints[2], fPoints[3]},
                   {fPoints[4], fPoints[5], fPoints[6], fPoints[7]},
                   {fPoints[3], fPoints[2], fPoints[6], fPoints[7]},
                   {fPoints[4], fPoints[5], fPoints[1], fPoints[0]},
                   {fPoints[4], fPoints[0], fPoints[3], fPoints[7]},
                   {fPoints[1], fPoints[2], fPoints[6], fPoints[5]}};
            */
            if(colCheck == 0)
            {
                //Red NEAR
                returnColor.color = float4(1.0f, 0.0f, 0.0f, 1.0f);
            }
            else if(colCheck == 1)
            {
                //Green Far
                returnColor.color = float4(0.0f, 1.0f, 0.0f, 1.0f);
            }
            else if(colCheck == 2)
            {
                //blue Right side
                returnColor.color = float4(0.0f, 0.0f, 1.0f, 1.0f);
            }
            else if(colCheck == 3)
            {
                //Yellow Left sde
                returnColor.color = float4(1.0f, 1.0f, 0.0f, 1.0f);
            }
            else if(colCheck == 4)
            {
                //teal TOP
                returnColor.color = float4(0.0f, 1.0f, 1.0f, 1.0f);
            }
            else if(colCheck == 5)
            {
                //Pink BOTTOM
                returnColor.color = float4(1.0f, 0.0f, 1.0f, 1.0f);
            }
        }
        else if(intersectsQuad(interPoint, t, quad0, quad1, quad2, quad3, quadNorm))
        {
            float2 quadTexCoords = float2((interPoint.x - quad1.x)/(quad2.x-quad1.x), (interPoint.z - quad3.z)/(quad2.z-quad3.z)) * 10.0f;
            returnColor.color = tex2D(floor, quadTexCoords);  
        }  
        else
        { 
          returnColor.color = texCUBE(cMap, reflecVec);
        }
    }
    else
    {
        returnColor.color = texCUBE(cMap, eyeToPix);
    }

    return returnColor;
}




