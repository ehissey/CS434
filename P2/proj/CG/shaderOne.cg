
struct VertexDataInput {
	float4 vertex: POSITION;
	float3 normal: NORMAL;
	float3 color: COLOR;
};

struct VertexDataOutput {
	float4 projv  : POSITION;
	float4 color : COLOR;
	float3 vertex: TEXCOORD0;
	float3 normal: TEXCOORD1;
};

struct PixelDataOutput {
	float4 color : COLOR0;
};

VertexDataOutput VertexMain(VertexDataInput vdi, 
  uniform float4x4 modelViewProj) {

  VertexDataOutput ret;
  ret.projv = mul(modelViewProj, vdi.vertex);
  ret.color = float4(vdi.color, 1.0f);
  ret.vertex = vdi.vertex.xyz;
  ret.normal = vdi.normal;

  return ret;

}

TRIANGLE void GeometryMain(AttribArray<VertexDataOutput> tverts,
	uniform float4x4 modelViewProj) {

	emitVertex(tverts[0]);
	emitVertex(tverts[1]);
	emitVertex(tverts[2]);
	return;

}

float quickCross(float2 v, float2 w)
{
    return v.x*w.y - v.y*w.x;
}

PixelDataOutput FragmentMain
(   VertexDataOutput pdi, 
	uniform float3 eyeCam, 
    uniform float4x4 diProjMatrix,
    uniform int u, uniform int v,
    uniform int w, uniform int h,
    uniform float3 lightPos)
{ 
    PixelDataOutput ret;

    float4 num = mul(diProjMatrix, float4(pdi.vertex.xyz,1));
    num = ((num/num.w)+1.0f)/2.0f;

    int compU = (int)(num.x * w);
    int compV = (int)(num.y * h);

    ret.color = float4(num.xyz, 1);

    
    if(compV == v && compU == u)
    {
        ret.color = pdi.color;
    }
    else
    {
        ret.color = float4(0,0,0,0);
    }

    return ret;
}